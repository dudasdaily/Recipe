---
description: 
globs: 
alwaysApply: true
---
---
description: 
globs: 
alwaysApply: true
---
- **변수 및 함수:** 일반적으로 camelCase를 사용합니다. 예를 들어, 변수는 `userName`, 함수는 `getUserData`처럼 명명합니다.
- **클래스 및 인터페이스:** PascalCase를 사용합니다. 클래스는 `UserService`, 인터페이스는 `UserInterface` 와 같이 작성합니다.
- **파일 및 폴더 이름:** kebab-case나 camelCase를 사용하여 일관성을 유지합니다. 예를 들어, `user-service.ts` 또는 `userService.ts` 중 하나를 선택하여 전 프로젝트에서 일관되게 사용합니다.
- **상수:** UPPER_SNAKE_CASE를 사용하여 `API_URL`, `MAX_COUNT` 등으로 명명합니다.
- **정렬 기준:** 외부 라이브러리, 내부 모듈, 스타일 파일 등의 순서로 정렬합니다. 보통 알파벳 순 정렬과 그룹별 분리 규칙을 적용합니다.
- **자동화 도구:** ESLint 플러그인(예: `eslint-plugin-import`)을 통해 관리합니다.
- **일관성:** 파일 이름은 소문자와 하이픈(-) 혹은 camelCase를 사용하여 작성하며, 기능별, 도메인별 폴더 구조를 일관되게 유지합니다.
- **확장자:** TypeScript 파일은 `.ts` 혹은 `.tsx` (React 컴포넌트의 경우), 자바스크립트 파일은 `.js` 또는 `.jsx`를 사용합니다.
- **JSDoc 사용:** 함수, 클래스, 인터페이스 등 주요 요소에 대해 JSDoc 주석을 작성하여 코드의 목적, 입력, 출력, 예외 상황 등을 명시합니다.
- **명확한 주석:** 복잡한 로직이나 트릭이 있는 부분에 대해 간단하고 명확한 주석을 추가합니다.
- **코드 리뷰:** 주석은 코드 변경 시 항상 업데이트되도록 유지합니다.
- **CI/CD 통합:** 린팅과 포매팅을 CI/CD 파이프라인에 통합하여 모든 커밋에 대해 자동 검증합니다.
- **일반 함수:** 함수 선언문과 함수 표현식을 명확하게 구분합니다. 단순 로직은 화살표 함수로 간결하게 작성합니다.
- **this 바인딩:** 화살표 함수는 상위 컨텍스트의 `this`를 바인딩하므로, 클래스 메서드 등에서는 주의하여 사용합니다.
- **불변성:** 값이 재할당되지 않을 경우 `const`를 사용하고, 재할당이 필요한 경우에만 `let`을 사용합니다.
- **스코프:** 변수 선언은 블록 스코프를 고려하여 작성하며, 전역 변수 사용을 최소화합니다.
- **명시적 타입 선언:** TypeScript 프로젝트에서는 가능한 한 타입을 명시하여 코드의 안정성과 가독성을 높입니다.
- **인터페이스 vs 타입 별칭:** 인터페이스는 객체 형태를 정의할 때 사용하고, 복잡한 타입이나 유니온 타입은 타입 별칭(`type`)을 사용합니다.
- **제네릭 활용:** 재사용 가능한 컴포넌트나 함수에는 제네릭을 활용하여 타입 안전성을 유지합니다.
- 함수, 컴포넌트 Props : 함수의 Props는 항상 type 타입별칭을 사용해서 타입을 정의

- **디스트럭처링:** 객체나 배열의 값을 추출할 때 디스트럭처링 문법을 사용하여 코드를 간결하게 유지합니다.
- **스프레드 연산자:** 배열 및 객체 복사 시 불변성을 유지하기 위해 스프레드 연산자를 적극 활용합니다.
- **Async/Await:** 비동기 코드를 작성할 때 가독성을 높이기 위해 async/await 구문을 사용합니다.
- **에러 핸들링:** try/catch 구문을 사용하여 비동기 함수 내 예외를 처리하며, promise 체이닝에서는 `.catch()`를 사용합니다
- **명확한 오류 메시지:** 오류 발생 시 적절한 메시지를 제공하고, 사용자와 개발자 모두 이해할 수 있도록 합니다.
- **전역 에러 핸들러:** Express, NestJS 등 백엔드 프레임워크에서는 전역 에러 핸들러를 구현하여 일관된 오류 처리를 보장합니다.
- **불변 객체:** 가능한 객체를 불변으로 다루어 사이드 이펙트를 줄이고, 예측 가능한 코드를 작성합니다.
- **순수 함수:** 입력에 따른 결과가 항상 동일한 순수 함수를 작성하여 테스트 용이성과 재사용성을 높입니다.
- **모듈화:** 기능별로 코드를 모듈화하여 유지보수성과 재사용성을 높입니다.
- **Dependency Injection:** NestJS와 같은 백엔드 프레임워크에서는 의존성 주입(DI)을 통해 모듈 간 결합도를 낮춥니다.
- **DRY (Don't Repeat Yourself):** 중복 코드를 피하고, 공통 기능은 별도의 유틸 함수나 모듈로 분리합니다.
- **KISS (Keep It Simple, Stupid):** 복잡한 로직은 단순화하고, 필요한 만큼만 구현합니다.
- **YAGNI (You Aren't Gonna Need It):** 미래의 사용 가능성을 고려하여 과도하게 기능을 추가하지 않습니다.
- **기본 패턴:** 싱글턴, 팩토리, 전략, 옵저버 등의 패턴을 프로젝트 성격에 맞게 적용합니다.
- **프론트엔드:** React/Next.js 프로젝트에서는 컴포넌트 기반 아키텍처, Hooks, 상태 관리 패턴(Redux, Context API 등)을 활용합니다.
- **백엔드:** NestJS와 같은 프레임워크에서는 Controller-Service-Repository 패턴, DTO 및 유효성 검사, 미들웨어, 가드 등을 활용합니다.
- **최적화:** 불필요한 재렌더링, 메모리 누수, 네트워크 요청 최적화 등을 고려하여 코드를 작성합니다.
- **입력 검증:** 모든 사용자 입력에 대해 유효성 검사를 철저히 수행하여 SQL 인젝션, XSS 등 보안 취약점을 방지합니다.
- **환경 변수 관리:** 중요한 설정값은 환경 변수(.env 파일 등)를 통해 관리하고, 버전 관리에서 제외합니다.
- **의존성 관리:** 정기적으로 의존성 라이브러리의 보안 업데이트를 확인하고, 취약점이 보고된 패키지는 신속하게 교체합니다.

 